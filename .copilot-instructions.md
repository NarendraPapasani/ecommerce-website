# 🛒 BlinkShop - GitHub Copilot Instructions

## 📋 Project Overview

**BlinkShop** is a modern, full-stack ecommerce platform built with React and Node.js. It features a dark theme with blue accents, comprehensive product management, secure authentication, payment processing, and a complete shopping experience.

**Live Demo**: [https://ecommified.netlify.app](https://ecommified.netlify.app)

## 🏗️ Architecture & Tech Stack

### Frontend (Client)

- **Framework**: React 18 with functional components and hooks
- **Build Tool**: Vite for fast development and building
- **Styling**: Tailwind CSS with dark theme (zinc-950 backgrounds)
- **UI Library**: Shadcn/ui components for accessibility and consistency
- **Routing**: React Router Dom v6 with protected routes
- **State Management**: React hooks (useState, useEffect, custom hooks)
- **HTTP Client**: Axios for API communication
- **Authentication**: JWT tokens stored in cookies
- **Forms**: React Hook Form with Zod validation
- **Payment**: Razorpay integration
- **Icons**: Lucide React icons
- **Loading**: React Loader Spinner with skeleton screens

### Backend (Server)

- **Runtime**: Node.js with Express.js framework
- **Database**: MongoDB with Mongoose ODM
- **Authentication**: JWT tokens with bcryptjs password hashing
- **File Upload**: Cloudinary for image management
- **Email**: Nodemailer for transactional emails
- **Payment**: Razorpay server-side integration
- **Security**: CORS, cookie-parser, authentication middleware

## 🎨 Design System

### Color Palette

- **Primary Background**: `bg-zinc-950` (dark theme)
- **Secondary Background**: `bg-zinc-900` for cards and containers
- **Accent Colors**: Blue variants (`bg-blue-600`, `text-blue-400`)
- **Text Colors**: `text-white` for primary, `text-zinc-400` for secondary
- **Success**: Green variants (`bg-green-600`)
- **Error**: Red variants (`bg-red-600`)

### Typography

- **Primary Font**: Montserrat for headings and important text
- **Font Classes**: `font-['Montserrat']` for custom font application

### Layout Patterns

- **Grid System**: CSS Grid and Flexbox layouts
- **Responsive**: Mobile-first approach with sm:, md:, lg: breakpoints
- **Background Pattern**: Consistent grid pattern overlay on pages
- **Loading States**: Skeleton components for all major sections

## 📁 Project Structure

```
ecommerce-website/
├── client/                     # React Frontend
│   ├── public/                 # Static assets
│   ├── src/
│   │   ├── components/ui/      # Shadcn/ui components
│   │   ├── hooks/              # Custom React hooks
│   │   ├── lib/                # Utility functions
│   │   ├── Pages/              # Route components
│   │   │   ├── auth/           # Login, signup
│   │   │   ├── cart/           # Shopping cart
│   │   │   ├── checkout/       # Checkout process
│   │   │   ├── home/           # Homepage with hero
│   │   │   ├── orders/         # Order management
│   │   │   ├── products/       # Product catalog
│   │   │   ├── profile/        # User profile
│   │   │   ├── address/        # Address management
│   │   │   ├── wishlist/       # Wishlist
│   │   │   └── skeletons/      # Loading components
│   │   ├── App.jsx             # Main app with routing
│   │   └── main.jsx            # Entry point
│   └── package.json
└── server/                     # Node.js Backend
    ├── controllers/            # Route handlers
    ├── models/                 # MongoDB schemas
    ├── routes/                 # API endpoints
    ├── middleware/             # Auth middleware
    ├── lib/utils/              # Server utilities
    └── server.js               # Entry point
```

## 🔧 Key Components & Patterns

### Component Architecture

- **Functional Components**: Use React 18 functional components with hooks
- **Custom Hooks**: Extract logic into reusable hooks (e.g., `useInfiniteProducts`)
- **Shadcn/ui**: Use consistent UI components from the library
- **Loading States**: Implement skeleton screens for all async operations

### State Management Patterns

```jsx
// Custom hooks for complex state
const useInfiniteProducts = (initialFilters) => {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [hasInitialLoad, setHasInitialLoad] = useState(false);
  // ... rest of hook logic
};

// Optimistic UI updates
const handleDeleteItem = async (productId) => {
  // Immediately update UI
  setCartItems((prev) => prev.filter((item) => item.productId !== productId));

  try {
    await deleteItemAPI(productId);
    // Show success toast
  } catch (error) {
    // Revert state on error
    setCartItems(originalItems);
    // Show error toast
  }
};
```

### API Integration Patterns

```jsx
// Consistent API calling pattern
const fetchData = async () => {
  try {
    setLoading(true);
    const response = await axios.get(
      `${import.meta.env.VITE_API_BASE_URL}/api/endpoint`,
      {
        headers: { Authorization: `Bearer ${jwt}` },
      }
    );
    setData(response.data.data);
  } catch (error) {
    console.error("Error:", error);
    toast({ title: "Error", description: error.message });
  } finally {
    setLoading(false);
  }
};
```

### Responsive Design Patterns

```jsx
// Mobile-first responsive classes
<div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
  {/* Grid adapts: 1 col mobile, 2 col tablet, 4 col desktop */}
</div>

// Hide elements on mobile
<nav className="hidden md:block">
  {/* Desktop-only navigation */}
</nav>

// Responsive padding
<div className="py-0 md:py-8">
  {/* No padding mobile, padding desktop */}
</div>
```

## 🛠️ Development Guidelines

### Coding Standards

1. **Use TypeScript-style JSDoc comments** for function documentation
2. **Consistent naming**: camelCase for variables, PascalCase for components
3. **Error handling**: Always implement try-catch blocks for async operations
4. **Loading states**: Show skeleton loaders during data fetching
5. **Responsive design**: Mobile-first approach with proper breakpoints
6. **Accessibility**: Use semantic HTML and proper ARIA labels

### Component Creation

```jsx
// Standard component structure
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";

const ComponentName = ({ prop1, prop2 }) => {
  const navigate = useNavigate();
  const { toast } = useToast();
  const [state, setState] = useState(initialValue);

  useEffect(() => {
    // Side effects
  }, []);

  const handleAction = async () => {
    try {
      // Implementation
    } catch (error) {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
        className: "bg-red-600 border-red-600 text-white",
      });
    }
  };

  return (
    <div className="min-h-screen bg-zinc-950 relative">
      {/* Background pattern */}
      <div className="absolute inset-0 bg-[linear-gradient(to_right,#4f4f4f2e_1px,transparent_1px),linear-gradient(to_bottom,#4f4f4f2e_1px,transparent_1px)] bg-[size:14px_24px] [mask-image:radial-gradient(ellipse_60%_50%_at_50%_0%,#000_70%,transparent_100%)]" />

      <div className="container mx-auto px-4 py-8 relative z-10">
        {/* Content */}
      </div>
    </div>
  );
};

export default ComponentName;
```

### API Routes Pattern (Backend)

```javascript
// Standard route structure
const express = require("express");
const router = express.Router();
const {
  authenticateController,
} = require("../middleware/authenticateController");

// GET /api/resource
router.get("/", authenticateController, async (req, res) => {
  try {
    const { email } = req.user;
    const data = await Model.find({ email });

    res.status(200).json({
      status: "success",
      data: { items: data },
    });
  } catch (error) {
    res.status(500).json({
      status: "error",
      message: error.message,
    });
  }
});

module.exports = router;
```

## 🎯 Feature Implementation Guidelines

### Authentication Flow

- JWT tokens stored in httpOnly cookies
- Protected routes using `<ProtectedRoute>` wrapper
- Google OAuth integration available
- Automatic token refresh handling

### Product Management

- Infinite scroll pagination with `useInfiniteProducts` hook
- Advanced filtering (category, price range, search)
- Image carousel for product details
- Review and rating system

### Shopping Cart

- Optimistic UI updates for immediate feedback
- Real-time quantity adjustments
- Persistent cart state across sessions
- Integration with checkout flow

### Payment Processing

- Razorpay integration for secure payments
- Order tracking from placement to delivery
- Email confirmations for order updates
- Invoice generation for completed orders

### UI/UX Patterns

- **Toast Notifications**: 1-second duration, color-coded (green/red)
- **Loading States**: Skeleton screens with proper animation delays
- **Error Handling**: User-friendly error messages with actionable advice
- **Responsive Images**: Cloudinary integration with optimization

## 🧪 Testing Considerations

### Component Testing

- Test loading states and error boundaries
- Verify responsive behavior across breakpoints
- Test user interactions and form validations
- Ensure accessibility compliance

### API Testing

- Test authentication middleware
- Verify data validation and sanitization
- Test error handling and edge cases
- Ensure proper CORS configuration

## 🚀 Deployment Notes

### Environment Variables

```bash
# Client (.env)
VITE_API_BASE_URL=http://localhost:8000
VITE_RAZORPAY_KEY_ID=your_razorpay_key

# Server (.env)
MONGO_URI=your_mongodb_connection
JWT_SECRET=your_jwt_secret
CLOUDINARY_CLOUD_NAME=your_cloudinary_name
RAZORPAY_KEY_ID=your_razorpay_key
RAZORPAY_SECRET=your_razorpay_secret
```

### Build Commands

```bash
# Frontend build
cd client && npm run build

# Backend start
cd server && npm start
```

## 📚 Common Patterns & Examples

### Toast Notifications

```jsx
// Success toast
toast({
  title: "Success!",
  description: "Operation completed successfully.",
  variant: "default",
  className: "bg-green-600 border-green-600 text-white",
});

// Error toast
toast({
  title: "Error",
  description: "Something went wrong.",
  variant: "destructive",
  className: "bg-red-600 border-red-600 text-white",
});
```

### Loading Skeletons

```jsx
// Product grid skeleton
if (loading && products.length === 0) {
  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
      {Array.from({ length: 12 }).map((_, index) => (
        <ProductCardSkeleton key={`skeleton-${index}`} />
      ))}
    </div>
  );
}
```

### Form Validation

```jsx
// Using React Hook Form with Zod
const form = useForm({
  resolver: zodResolver(schema),
  defaultValues: { field: "" },
});

const onSubmit = async (data) => {
  try {
    await submitAPI(data);
    toast({ title: "Success", description: "Form submitted!" });
  } catch (error) {
    toast({
      title: "Error",
      description: error.message,
      variant: "destructive",
    });
  }
};
```

## 🎯 When Adding New Features

1. **Follow existing patterns** for consistency
2. **Implement loading states** for all async operations
3. **Add proper error handling** with user-friendly messages
4. **Ensure mobile responsiveness** with appropriate breakpoints
5. **Use Shadcn/ui components** for consistent styling
6. **Add skeleton screens** for better perceived performance
7. **Implement optimistic UI** updates where appropriate
8. **Follow the established color scheme** and typography
9. **Add proper TypeScript/JSDoc** documentation
10. **Test across different screen sizes** and interaction patterns

---

**Remember**: This is a production-ready ecommerce platform with a focus on user experience, performance, and maintainability. Always prioritize clean code, proper error handling, and consistent design patterns when extending functionality.